👋 Welcome to **Day 2** of 30 Days of Solidity! Today we will cover the following topics:

- Initializing a Contract
- Variables
- Datatypes

So let's start!

## 📜 Initializing a Contract

To create a new contract in Solidity, you can use the contract keyword like this:

```solidity copy
contract MyContract {
    // Code
}
```

In this example, "`MyContract`" is the name of the contract. 😎

While there are no strict rules for naming your contracts, there are some recommendations that are good to follow.Here are some suggestions:

- Contract names should be written in CapWords style. For example, `SimpleToken`, `SmartBank`, `CertificateHashRepository`, `Player`, `Congress`, and `Owned`. 🤓
- The name of the contract should match the name of the file it's in.
- If a contract file includes multiple contracts, the filename should match the core contract, but this isn't ideal and should be avoided if possible.

For example, if your contract's name is `Congress`, then the associated filename 📝 should be `Congress.sol`. Here's an example of how this would look in code:

```solidity filename="Congress.sol" copy
// SPDX-License-Identifier: GPL-3.0
pragma solidity ^0.8.7;

contract Congress {
    //...
}
```

By following these recommendations, you can help make your Solidity code more readable and easier to understand. 😊

## 📏 Variables

A variable is a named storage location in a Solidity program that holds a value of a certain data type. It can be changed during the execution of the program, and its value can be used in calculations and other operations.

While naming your variables in Solidity, it's important to follow some rules to ensure your code is readable and follows Solidity's syntax requirements.

👉 Here are a few things to keep in mind when naming your variables in Solidity:

- You should not use any of the Solidity reserved keywords as a variable name. For example, `break` or `boolean` variable names are not valid.
- Solidity variable names should not start with a numeral (`0-9`). They must begin with a letter or an underscore`_` character. For example, `123test` is an invalid variable name but `_123test` is a valid one.
- Solidity variable names are case-sensitive. For example, `Name` and `name` are two different variables.

Here are the keywords as per the latest Solidity version

```txt
after, alias, apply, auto, byte, case, copyof,
default, define, final, implements, in, inline,
let, macro, match, mutable, null, of, partial,
promise, reference, relocatable, sealed, sizeof,
static, supports, switch, typedef, typeof, var
```

## 💾 Datatype

📜 Solidity is a statically-typed language, which means that variables must be declared with a specific data type before they can be used. Solidity supports a wide range of data types that can be used to store different kinds of values. To declare a variable, use the following syntax:

```solidity copy
<datatype> <variablename>;
```

### 🔢 Integer Types:

Solidity has several integer data types that can be used to store integer values. Integers can be either _signed_ or _unsigned_. Signed integers can store both positive and negative values, while unsigned integers can only store non-negative values. The following are the integer data types available in Solidity:

- **uin**t: an unsigned integer. It can store non-negative integers. The size of uint is `256` bits.
- **int**: a signed integer. It can store both positive and negative integers. The size of int is `256` bits.
- **uint8** to **uint256**: unsigned integers with various bit sizes.
- **int8** to **int256**: signed integers with various bit sizes.

📝 Here's an example of how to declare a uint variable called myNumber:

```solidity copy
uint myNumber = 10;
```

### 🔢 Fixed Point Types:

Fixed point numbers are used to represent decimal numbers with a fixed number of decimal places. Solidity has two fixed point types: `ufixed` and `fixed`. The ufixed data type represents an unsigned fixed point number, while the fixed data type represents a signed fixed point number.

<Callout type="warning" emoji="⚠️">
  **Note** - Fixed point types are not fully supported yet. They can be
  declared, but cannot be assigned to or from. It's also still undecided which
  of the upcoming compiler versions will support them.
</Callout>

Keywords `ufixedMxN` and `fixedMxN`, where `M` represents the number of bits taken by the type and `N` represents how many decimal points are available.

- M must be divisible by 8 and goes from 8 to 256 bits.
- N must be between 0 and 80, inclusive.
- `ufixed` and `fixed` are aliases for `ufixed128x18` and `fixed128x18`, respectively.

The following are some examples of how to declare fixed point variables:

```solidity copy
fixed myFixedNumber = 1.23;
ufixed myUnsignedFixedNumber = 2.345;
```

### 🪢 String Types:

The string data type is used to store a sequence of characters. Strings are declared by using the string keyword. Here's an example:

```solidity copy
string myString = "Hello, world!";
```

we can also use bytes with string for example, with `bytes32 samevar = "stringliteral";{solidity}` the string literal is interpreted in its raw byte form when assigned to a bytes32 type.

### 👨‍💼 Address Types:

The address data type is used to store Ethereum addresses. The address type comes in two largely identical flavors:

- **address**: Holds a 20 byte value (size of an Ethereum address).
- **address payable**: Same as address, but with the additional members `transfer` and `send`.

The idea behind this distinction is that `address payable` is an address you can send Ether to, while you are not supposed to send Ether to a plain `address`, for example because it might be a smart contract that was not built to accept Ether.

Example,

```solidity copy
address myAddress = 0xAb8483F64d9C6d1EcF9b849Ae677dD3315835cb2;
```

### 🎭 Boolean Types:

The bool data type is used to store either true or false. Here's an example:

```solidity copy
bool myBoolean = true;
```

### 🎨 Unicode and Hexadecimal Literals

Solidity supports Unicode and hexadecimal literals. Unicode literals are used to represent special characters, while hexadecimal literals are used to represent values in hexadecimal format.

Regular string literals can only include ASCII characters, whereas Unicode literals, which are prefixed with the keyword `unicode`, can contain any valid UTF-8 sequence. They can also use the same escape sequences as conventional string literals.

Here are some examples:

```solidity copy
string memory a = unicode"Hello 😃";
```

Hexadecimal literals begin with the keyword `hex` and are surrounded by double or single quotes. Its content must be hexadecimal digits, with a single underscore acting as a divider between byte bounds.

For Example,

```solidity copy
bytes32 public myHex = hex"001122FF";
```

import { Callout } from "nextra-theme-docs";

<Callout type="info" emoji="ℹ️">
  Solidity also allows for the creation of user-defined data types, such as
  `arrays`, `structs`, `mappings`, and `iterable mappings`. These data types can
  be used to store more complex data structures and make it easier to work with
  large amounts of data. In the coming days of this series, we'll explore these
  data types in more detail, so stay tuned!
</Callout>

👀 And that's it! You now know about the different data types in Solidity and how to declare variables of each type. When declaring a variable, make sure to choose the data type that best fits the type of data you want to store.

## 🎯 Challenge

**❓ Build a simple smart contract called 'Contract.sol' and populate variables with the datatype we studied today.**

Ready for the solution, just expand the section below

<details>

<summary>⬇️ Answer</summary>

```solidity copy filename="Contract.sol"
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.14;

contract Contract {
    uint myUint = 10;
    fixed32x4 myFixed;
    string myString = "Hello World!";
    address myAddress = 0xBF4979305B43B0eB5Bb6a5C67ffB89408803d3e1;
    bool myBoolean = true;
    string public myUnicode = unicode"Hello 😃";
    bytes32 public myHex = hex"001122FF";
}
```

</details>

That's all for today! Keep learning and practicing Solidity, and we'll see you tomorrow for more blockchain awesomeness! ✨
